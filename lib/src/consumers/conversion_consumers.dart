import 'dart:collection';

import '../equality_comparer.dart';

extension ConversionConsumerExtensions<T> on Iterable<T> {
  /// Converts the iterable to a [HashMap].
  ///
  /// Iterates over the entire iterable, generating a [MapEntry] from each
  /// element with the [entrySelector] function then saving each generated
  /// entry in a [HashMap] under the generated key.
  ///
  /// If a duplicate key is produced, the value generated by a prior element is
  /// overwritten. As such, the length of the resulting [HashMap] is not guaranteed
  /// to be the same length as the iterable.
  ///
  /// Example:
  ///
  ///     void main() {
  ///       var list = [97, 98, 99];
  ///       var result = list.toHashMap((x) => MapEntry(x, String.fromCodeUnit(x)));
  ///
  ///       // Result: { 97: 'a', 98: 'b', 99: 'c' }
  ///     }
  ///

  ///
  Map<TKey, TValue> toHashMap<TKey, TValue>(
    MapEntry<TKey, TValue> Function(T) entrySelector, {
    bool modifiable = true,
  }) {
    final map = HashMap.fromEntries([for (var o in this) entrySelector(o)]);
    if (modifiable) return map;
    return UnmodifiableMapView(map);
  }

  /// Converts the iterable to a [LinkedHashMap].
  ///
  /// Iterates over the entire iterable, generating a [MapEntry] from each
  /// element with the [entrySelector] function then saving each generated
  /// entry in a [LinkedHashMap] under the generated key.
  ///
  /// If a duplicate key is produced, the value generated by a prior element is
  /// overwritten. As such, the length of the resulting [LinkedHashMap] is not guaranteed
  /// to be the same length as the iterable.
  ///
  /// Example:
  ///
  ///     void main() {
  ///       var list = [97, 98, 99];
  ///       var result = list.toLinkedHashMap((x) => MapEntry(x, String.fromCodeUnit(x)));
  ///
  ///       // Result: { 97: 'a', 98: 'b', 99: 'c' }
  ///     }
  ///

  ///
  Map<TKey, TValue> toLinkedHashMap<TKey, TValue>(
    MapEntry<TKey, TValue> Function(T) entrySelector, {
    bool modifiable = false,
  }) {
    final map =
        LinkedHashMap.fromEntries([for (var o in this) entrySelector(o)]);
    if (modifiable) return map;
    return UnmodifiableMapView(map);
  }

  /// Converts the iterable to a [Map].
  ///
  /// Iterates over the entire iterable, generating a [MapEntry] from each
  /// element with the [entrySelector] function then saving each generated
  /// entry in a [Map] under the generated key.
  ///
  /// If a duplicate key is produced, the value generated by a prior element is
  /// overwritten. As such, the length of the resulting [Map] is not guaranteed
  /// to be the same length as the iterable.
  ///
  /// Example:
  ///
  ///     void main() {
  ///       var list = [97, 98, 99];
  ///       var result = list.toMap((x) => MapEntry(x, String.fromCodeUnit(x)));
  ///
  ///       // Result: { 97: 'a', 98: 'b', 99: 'c' }
  ///     }
  ///

  ///
  Map<TKey, TValue> toMap<TKey, TValue>(
    MapEntry<TKey, TValue> Function(T) entrySelector, {
    bool modifiable = false,
  }) =>
      toLinkedHashMap(entrySelector, modifiable: modifiable);

  /// Converts the iterable to a [SplayTreeMap].
  ///
  /// Iterates over the entire iterable, generating a [MapEntry] from each
  /// element with the [entrySelector] function then saving each generated
  /// entry in a [HashMap] under the generated key.
  ///
  /// If a duplicate key is produced, the value generated by a prior element is
  /// overwritten. As such, the length of the resulting [SplayTreeMap] is not guaranteed
  /// to be the same length as the iterable.
  ///
  /// Example:
  ///
  ///     void main() {
  ///       var list = [97, 98, 99];
  ///       var result = list.toSplayTreeMap((x) => MapEntry(x, String.fromCodeUnit(x)));
  ///
  ///       // Result: { 97: 'a', 98: 'b', 99: 'c' }
  ///     }
  ///

  ///
  Map<TKey, TValue> toSplayTreeMap<TKey, TValue>(
    MapEntry<TKey, TValue> Function(T) entrySelector, {
    int Function(TKey k1, TKey k2) keyComparer,
    bool modifiable = false,
  }) {
    keyComparer ??= EqualityComparer.forType<TKey>().sort;

    final map = SplayTreeMap<TKey, TValue>(keyComparer);
    map.addEntries([for (var o in this) entrySelector(o)]);
    if (modifiable) return map;
    return UnmodifiableMapView(map);
  }

  /// Converts the iterable to a [Stream].
  ///
  /// Wraps the iterable in a [Stream] that emits all the values in this iterable. If
  /// iteration is paused, the stream's events will be paused and vice versa. If an
  /// error is thrown during iteration, the stream will emit the error and then close.
  ///
  /// If `isBroadcast` is set to true, the stream will be a broadcast stream. Otherwise,
  /// the stream will be a single-subscription stream. (Default is false.)
  ///
  /// (This is a convenience method that wraps [Stream.fromIterable].)
  Stream<T> toStream({bool isBroadcast = false}) {
    final stream = Stream.fromIterable(this);
    if (isBroadcast) return stream.asBroadcastStream();
    return stream;
  }
}
