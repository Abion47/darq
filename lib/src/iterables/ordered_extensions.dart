import '../equality_comparer.dart';

extension OrderedIterableExtensions<T> on Iterable<T> {
  /// Sorts the iteration in ascending (least-to-greatest) order.
  ///
  /// First, [orderBy] iterates over the entire iterable, creating a list of
  /// keys generated by [keySelector] associated to their corresponding
  /// elements. Then a QuickSort algorithm is applied to the keys, using the
  /// [sorter] property in [keyComparer] to determine sort order. Afterwards,
  /// the resulting iterable will consist of the elements in the source
  /// iterable in the order determined by the sorted list of keys.
  ///
  /// When the type of the iterable is one of the below types, the
  /// [EqualityComparer] can be omitted. In this case, the function defaults to
  /// predefined minimum functions depending on the type:
  ///
  /// - Numeric types (`num`, `int`, `double`) will be sorted by their values in ascending order.
  /// - `String` types will be sorted in alphabetic order.
  ///
  /// If the iterable type is not one of these types and the [EqualityComparer]
  /// is not provided, the order of the resulting iterable is unpredictable.
  ///
  /// If the iterable is already sorted in ascending order, the resulting
  /// iterable will be unchanged.
  ///
  /// Example:
  ///
  ///     void main() {
  ///       final list = [4, 3, 5, 2, 1];
  ///       final result = list.orderBy((x) => x);
  ///
  ///       // Result: [1, 2, 3, 4, 5]
  ///     }
  ///

  ///
  Iterable<T> orderBy<TKey>(
    TKey Function(T) keySelector, {
    EqualityComparer<TKey> keyComparer,
  }) {
    ArgumentError.checkNotNull(keySelector);
    return _InternalOrderedIterable(this, keySelector, keyComparer, false);
  }

  /// Sorts the iteration in descending (greatest-to-least) order.
  ///
  /// First, [orderByDescending] iterates over the entire iterable, creating a
  /// list of keys generated by [keySelector] associated to their corresponding
  /// elements. Then a QuickSort algorithm is applied to the keys, using the
  /// [sorter] property in [keyComparer] to determine sort order. Afterwards,
  /// the resulting iterable will consist of the elements in the source
  /// iterable in the order determined by the sorted list of keys.
  ///
  /// When the type of the iterable is one of the below types, the
  /// [EqualityComparer] can be omitted. In this case, the function defaults to
  /// predefined minimum functions depending on the type:
  ///
  /// - Numeric types (`num`, `int`, `double`) will be sorted by their values in descending order.
  /// - `String` types will be sorted in reverse-alphabetic order.
  ///
  /// If the iterable type is not one of these types and the [EqualityComparer]
  /// is not provided, the order of the resulting iterable is unpredictable.
  ///
  /// If the iterable is already sorted in descending order, the resulting
  /// iterable will be unchanged.
  ///
  /// Example:
  ///
  ///     void main() {
  ///       final list = [4, 3, 5, 2, 1];
  ///       final result = list.orderByDescending((x) => x);
  ///
  ///       // Result: [5, 4, 3, 2, 1]
  ///     }
  ///

  ///
  Iterable<T> orderByDescending<TKey>(
    TKey Function(T) keySelector, {
    EqualityComparer<TKey> keyComparer,
  }) {
    ArgumentError.checkNotNull(keySelector);
    return _InternalOrderedIterable(this, keySelector, keyComparer, true);
  }

  /// Reverses the order of the iterable.
  ///
  /// The iterable is iterated over and stored in a list. The resulting
  /// iterable is the product of then iterating over that list in reverse
  /// order.
  ///
  /// Example:
  ///
  ///     void main() {
  ///       final list = [1, 2, 3, 4];
  ///       final result = list.reverse();
  ///
  ///       // Result: [4, 3, 2, 1]
  ///     }
  ///

  ///
  Iterable<T> reverse() {
    return toList().reversed;
  }

  /// Adds a secondary sorting pass to iteration in ascending
  /// (least-to-greatest) order.
  ///
  /// [thenBy] applies to an iterable that has been sorted by [orderBy] or
  /// [orderByDescending] (or another [thenBy] or [thenByDescending]). Once the
  /// previous sorting mechanism is processed, the keys are then sorted again
  /// using the [EqualityComparer] given to this method. (The process of sorting
  /// is identical to [groupBy].)
  ///
  /// When the type of the iterable is one of the below types, the
  /// [EqualityComparer] can be omitted. In this case, the function defaults to
  /// predefined minimum functions depending on the type:
  ///
  /// - Numeric types (`num`, `int`, `double`) will be sorted by their values in ascending order.
  /// - `String` types will be sorted in alphabetic order.
  ///
  /// If the iterable type is not one of these types and the [EqualityComparer]
  /// is not provided, the order of the resulting iterable is unpredictable.
  ///
  /// If the iterable is already sorted in ascending order, the resulting
  /// iterable will be unchanged.
  ///
  /// Example:
  ///
  ///     void main() {
  ///       var list = ['ab', 'a', 'c', 'aa', ''];
  ///       // Sort by string length followed by alphabetical order
  ///       var result = list.orderBy((c) => c.length)
  ///                        .thenBy((c) => c);
  ///
  ///       // Result: ['', 'a', 'c', 'aa', 'ab']
  ///     }
  ///

  ///
  Iterable<T> thenBy<TKey>(
    TKey Function(T) keySelector, {
    EqualityComparer<TKey> keyComparer,
  }) {
    ArgumentError.checkNotNull(keySelector);
    if (this is! _InternalOrderedIterable) {
      throw UnsupportedError(
          'thenBy must be called immediately following a call to orderBy, orderByDescending, thenBy, or thenByDescending.');
    }
    return (this as dynamic)
        .createOrderedIterable<TKey>(keySelector, keyComparer, false);
  }

  /// Adds a secondary sorting pass to iteration in ascending
  /// (least-to-greatest) order.
  ///
  /// [thenByDescending] applies to an iterable that has been sorted by [orderBy] or
  /// [orderByDescending] (or another [thenBy] or [thenByDescending]). Once the
  /// previous sorting mechanism is processed, the keys are then sorted again
  /// using the [EqualityComparer] given to this method. (The process of sorting
  /// is identical to [groupBy].)
  ///
  /// When the type of the iterable is one of the below types, the
  /// [EqualityComparer] can be omitted. In this case, the function defaults to
  /// predefined minimum functions depending on the type:
  ///
  /// - Numeric types (`num`, `int`, `double`) will be sorted by their values in ascending order.
  /// - `String` types will be sorted in alphabetic order.
  ///
  /// If the iterable type is not one of these types and the [EqualityComparer]
  /// is not provided, the order of the resulting iterable is unpredictable.
  ///
  /// If the iterable is already sorted in ascending order, the resulting
  /// iterable will be unchanged.
  ///
  /// Example:
  ///
  ///     void main() {
  ///       var list = ['ab', 'a', 'c', 'aa', ''];
  ///       // Sort by string length followed by reverse alphabetical order
  ///       var result = list.orderBy((c) => c.length)
  ///                        .thenByDescending((c) => c);
  ///
  ///       // Result: ['', 'c', 'a', 'ab', 'aa']
  ///     }
  ///

  ///
  Iterable<T> thenByDescending<TKey>(
    TKey Function(T) keySelector, {
    EqualityComparer<TKey> keyComparer,
  }) {
    ArgumentError.checkNotNull(keySelector);
    if (this is! _InternalOrderedIterable) {
      throw UnsupportedError(
          'thenByDescending must be called immediately following a call to orderBy, orderByDescending, thenBy, or thenByDescending.');
    }
    return (this as dynamic)
        .createOrderedIterable<TKey>(keySelector, keyComparer, true);
  }
}

abstract class _OrderedIterable<T> extends Iterable<T> {
  Iterable<T> source;

  _OrderedIterable(this.source);
  _IterableSorter<T> getIterableSorter(_IterableSorter<T> next);

  _OrderedIterable<T> createOrderedIterable<TNewKey>(
      TNewKey Function(T) keySelector,
      EqualityComparer<TNewKey> keyComparer,
      bool descending) {
    final result = _InternalOrderedIterable<T, TNewKey>(
        source, keySelector, keyComparer, descending);
    result.parent = this;
    return result;
  }
}

class _InternalOrderedIterable<TValue, TKey> extends _OrderedIterable<TValue> {
  _OrderedIterable<TValue> parent;
  TKey Function(TValue) keySelector;
  EqualityComparer<TKey> keyComparer;
  bool descending;

  _InternalOrderedIterable(Iterable<TValue> source, this.keySelector,
      this.keyComparer, this.descending)
      : super(source) {
    this.source = source;
  }

  @override
  Iterator<TValue> get iterator => iterate().iterator;
  Iterable<TValue> iterate() sync* {
    final buffer = source.toList();
    if (buffer.isNotEmpty) {
      final sorter = getIterableSorter(null);
      final map = sorter.sort(buffer, buffer.length);
      yield* _OrderedBuffer(buffer, map);
    }
  }

  @override
  _IterableSorter<TValue> getIterableSorter(_IterableSorter<TValue> next) {
    _IterableSorter<TValue> sorter = _InternalIterableSorter<TValue, TKey>(
        keySelector, keyComparer, descending, next);
    if (parent != null) sorter = parent.getIterableSorter(sorter);
    return sorter;
  }
}

abstract class _IterableSorter<T> {
  void computeKeys(List<T> elements, int count);
  int compareKeys(int idx1, int idx2);

  List<int> sort(List<T> elements, int count) {
    computeKeys(elements, count);
    final map = List<int>.generate(count, (i) => i, growable: false);
    quickSort(map, 0, count - 1);
    return map;
  }

  void quickSort(List<int> map, int left, int right) {
    do {
      var i = left;
      var j = right;
      final x = map[i + ((j - i) >> 1)];
      do {
        while (i < map.length && compareKeys(x, map[i]) > 0) {
          i++;
        }
        while (j >= 0 && compareKeys(x, map[j]) < 0) {
          j--;
        }
        if (i > j) break;
        if (i < j) {
          final temp = map[i];
          map[i] = map[j];
          map[j] = temp;
        }
        i++;
        j--;
      } while (i <= j);
      if (j - left <= right - i) {
        if (left < j) quickSort(map, left, j);
        left = i;
      } else {
        if (i < right) quickSort(map, i, right);
        right = j;
      }
    } while (left < right);
  }
}

class _InternalIterableSorter<TValue, TKey> extends _IterableSorter<TValue> {
  TKey Function(TValue) keySelector;
  EqualityComparer<TKey> comparer;
  bool descending;
  _IterableSorter<TValue> next;
  List<TKey> keys;

  _InternalIterableSorter(
    this.keySelector,
    this.comparer,
    this.descending,
    this.next,
  ) {
    comparer ??= EqualityComparer.forType<TKey>();
  }

  @override
  void computeKeys(List<TValue> elements, int count) {
    keys = List<TKey>(count);
    for (var i = 0; i < count; i++) {
      keys[i] = keySelector(elements[i]);
    }
    if (next != null) next.computeKeys(elements, count);
  }

  @override
  int compareKeys(int index1, int index2) {
    final c = comparer.sort(keys[index1], keys[index2]);
    if (c == 0) {
      if (next == null) return index1 - index2;
      return next.compareKeys(index1, index2);
    }
    return descending ? -c : c;
  }
}

class _OrderedBuffer<T> extends Iterable<T> {
  List<T> data;
  List<int> orderedMap;

  _OrderedBuffer(this.data, this.orderedMap);

  @override
  Iterator<T> get iterator => iterate().iterator;
  Iterable<T> iterate() sync* {
    for (var index in orderedMap) {
      yield data[index];
    }
  }
}
